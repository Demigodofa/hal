# PSEUDOCODE / PLAN
# 1) Chrome extension (MV3)
#    - content.js watches ChatGPT DOM for code blocks marked [KEV_AI::command] ... [/KEV_AI::command].
#    - Extract JSON payload(s), compute a stable id = sha256(JSON text), visually tag the block as "queued/sent".
#    - Send the payload + id to service_worker.js via chrome.runtime.sendMessage.
#    - Options page stores config: renderEndpoint, localEndpoint, sharedSecret, routeStrategy (auto/local/render/both).
#    - Service worker posts commands to the chosen endpoint(s), with headers:
#         X-KEV-Signature: HMAC-SHA256(secret, raw_payload)
#         Content-Type: application/json
#      and body: { id, raw, parsed, source: "chatgpt-web", ts }.
#    - De-dup in SW by id (in-memory and chrome.storage) to avoid resends.
#
# 2) Local FastAPI relay (runs on your machine)
#    - Endpoint: POST /kev_ai/listener
#    - Verify HMAC vs X-KEV-Signature.
#    - Validate schema; allow commands with target=="local" OR op in {file_ops, system_control}.
#    - SSD root discovery: scan common mount points; fallback to config ENV or CLI flag.
#    - Safe path resolution: disallow path traversal; all ops confined under SSD_ROOT.
#    - Supported ops: read_file, write_file, list_dir, mkdirs, delete_file, run_cmd (optional, gated).
#    - Optional: forward non-local ops to Render endpoint.
#    - Health endpoints + minimal logs.
#
# 3) Command schema (backwards-compatible wrapper)
#    - Delimited block in ChatGPT:
#      [KEV_AI::command]
#      {
#        "id": "<uuid|hash>",
#        "target": "local" | "render" | "both",
#        "op": "file_ops.write_file",  # dot-path or route name
#        "args": { "path": "memory/short_term/seed.json", "content": "...", "encoding": "utf-8" },
#        "meta": { "author": "user", "nonce": "..." }
#      }
#      [/KEV_AI::command]
#    - Extension forwards raw JSON and parsed object; your existing Render /kev_ai/listener can keep its own schema.
#
# 4) Security
#    - Shared secret via HMAC; optional allowlist of origins; CORS only for extension.
#    - Local relay requires --allow-run to enable system commands.
#    - No network access from local relay beyond optional forward to Render.
#
# 5) Quick start
#    - Install extension → set endpoints + secret.
#    - Run local relay: `python -m local_relay.app --ssd-root /Volumes/PORTABLE_SSD` (or auto-detect).
#    - Drop a command block into ChatGPT; observe badges; files appear on SSD or hit Render.


########################################
# repo/
# ├─ extension/
# │  ├─ manifest.json
# │  ├─ content.js
# │  ├─ service_worker.js
# │  ├─ options.html
# │  └─ options.js
# └─ local_relay/
#    ├─ app.py
#    ├─ security.py
#    ├─ ssd.py
#    ├─ schemas.py
#    ├─ requirements.txt
#    └─ README.md
########################################


############################
# extension/manifest.json
############################
{
  "manifest_version": 3,
  "name": "HAL Relay: ChatGPT → HAL",
  "version": "0.1.0",
  "description": "Detect [KEV_AI::command] blocks in ChatGPT and forward to HAL endpoints (Render/local).",
  "permissions": ["storage", "activeTab", "scripting"],
  "host_permissions": [
    "https://chat.openai.com/*",
    "https://*.openai.com/*",
    "https://hal-ku4c.onrender.com/*",
    "http://127.0.0.1/*",
    "http://localhost/*"
  ],
  "content_scripts": [
    {
      "matches": ["https://chat.openai.com/*", "https://chatgpt.com/*"],
      "js": ["content.js"],
      "run_at": "document_idle"
    }
  ],
  "background": { "service_worker": "service_worker.js" },
  "options_page": "options.html",
  "icons": {"16": "icon16.png", "48": "icon48.png", "128": "icon128.png"}
}


############################
# extension/content.js
############################
// Minimal DOM watcher for ChatGPT; extracts [KEV_AI::command] JSON blocks.
(function () {
  const MARK_START = "[KEV_AI::command]";
  const MARK_END = "[/KEV_AI::command]";

  const findBlocks = (root) => {
    const blocks = [];
    const codeNodes = root.querySelectorAll('pre, code, .markdown');
    codeNodes.forEach((node) => {
      const text = node.innerText;
      if (!text) return;
      const start = text.indexOf(MARK_START);
      const end = text.indexOf(MARK_END);
      if (start !== -1 && end !== -1 && end > start) {
        const raw = text.slice(start + MARK_START.length, end).trim();
        blocks.push({ node, raw });
      }
    });
    return blocks;
  };

  const tagNode = (node, status, title) => {
    // why: non-invasive UI feedback in ChatGPT
    node.style.outline = status === 'sent' ? '2px solid #22c55e' : status === 'error' ? '2px solid #ef4444' : '2px dashed #a3a3a3';
    node.setAttribute('data-hal-relay', status);
    if (title) node.setAttribute('title', title);
  };

  const hash = async (str) => {
    const enc = new TextEncoder();
    const buf = await crypto.subtle.digest('SHA-256', enc.encode(str));
    return Array.from(new Uint8Array(buf)).map(b => b.toString(16).padStart(2, '0')).join('');
  };

  const processBlock = async (node, raw) => {
    try {
      const parsed = JSON.parse(raw);
      const id = (parsed && parsed.id) ? String(parsed.id) : await hash(raw);
      const payload = { id, raw, parsed, source: 'chatgpt-web', ts: Date.now() };
      chrome.runtime.sendMessage({ type: 'HAL_CMD', payload }, (resp) => {
        if (chrome.runtime.lastError) {
          tagNode(node, 'error', chrome.runtime.lastError.message);
          return;
        }
        tagNode(node, resp?.ok ? 'sent' : 'error', resp?.message || '');
      });
    } catch (e) {
      tagNode(node, 'error', 'JSON parse failed');
    }
  };

  const scan = (root = document) => {
    const blocks = findBlocks(root);
    blocks.forEach(({ node, raw }) => {
      if (node.getAttribute('data-hal-relay')) return; // dedupe per node
      tagNode(node, 'queued', 'HAL Relay: queued');
      processBlock(node, raw);
    });
  };

  const mo = new MutationObserver((muts) => {
    for (const m of muts) {
      m.addedNodes?.forEach((n) => {
        if (!(n instanceof HTMLElement)) return;
        scan(n);
      });
    }
  });

  window.addEventListener('load', () => {
    scan();
    mo.observe(document.body, { childList: true, subtree: true });
  });
})();


############################
# extension/service_worker.js
############################
const DEFAULTS = {
  renderEndpoint: 'https://hal-ku4c.onrender.com/kev_ai/listener',
  localEndpoint: 'http://127.0.0.1:8765/kev_ai/listener',
  sharedSecret: '',
  routeStrategy: 'auto' // auto|render|local|both
};

let cache = new Set();

chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
  if (msg?.type !== 'HAL_CMD') return;
  handleCommand(msg.payload).then((r) => sendResponse(r));
  return true; // async
});

async function loadCfg() {
  return new Promise((resolve) => {
    chrome.storage.sync.get(DEFAULTS, (cfg) => resolve({ ...DEFAULTS, ...cfg }));
  });
}

async function hmacSHA256(key, message) {
  const enc = new TextEncoder();
  const cryptoKey = await crypto.subtle.importKey(
    'raw', enc.encode(key), { name: 'HMAC', hash: 'SHA-256' }, false, ['sign']
  );
  const sig = await crypto.subtle.sign('HMAC', cryptoKey, enc.encode(message));
  return Array.from(new Uint8Array(sig)).map(b => b.toString(16).padStart(2, '0')).join('');
}

async function postTo(url, secret, body) {
  const signature = secret ? await hmacSHA256(secret, body.raw) : undefined;
  const res = await fetch(url, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      ...(signature ? { 'X-KEV-Signature': signature } : {})
    },
    body: JSON.stringify(body)
  });
  const json = await res.json().catch(() => ({}));
  return { ok: res.ok, status: res.status, json };
}

async function handleCommand(payload) {
  try {
    const cfg = await loadCfg();
    if (cache.has(payload.id)) return { ok: true, message: 'duplicate ignored' };

    const target = (payload?.parsed?.target || '').toLowerCase();
    const strategy = cfg.routeStrategy;
    const wantLocal = strategy === 'local' || strategy === 'both' || (strategy === 'auto' && (target === 'local' || target === 'both'));
    const wantRender = strategy === 'render' || strategy === 'both' || (strategy === 'auto' && (target === 'render' || target === 'both' || !target));

    const posts = [];
    if (wantLocal) posts.push(postTo(cfg.localEndpoint, cfg.sharedSecret, payload));
    if (wantRender) posts.push(postTo(cfg.renderEndpoint, cfg.sharedSecret, payload));

    const results = await Promise.allSettled(posts);
    cache.add(payload.id);

    const ok = results.some(r => r.status === 'fulfilled' && r.value.ok);
    const msg = results.map(r => r.status === 'fulfilled' ? `${r.value.status}` : 'ERR').join(' | ');
    return { ok, message: msg };
  } catch (e) {
    return { ok: false, message: e?.message || 'error' };
  }
}


############################
# extension/options.html
############################
<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>HAL Relay Options</title>
    <style>
      body { font-family: ui-sans-serif, system-ui; margin: 24px; }
      label { display:block; margin-top:12px; }
      input, select { width: 100%; padding: 8px; }
      .row { display:flex; gap:12px; }
      .row > div { flex:1; }
      .muted { color:#6b7280; font-size:12px; }
      button { margin-top:18px; padding:10px 14px; }
    </style>
  </head>
  <body>
    <h1>HAL Relay</h1>
    <label>Render Listener URL
      <input id="renderEndpoint" placeholder="https://.../kev_ai/listener" />
    </label>
    <label>Local Listener URL
      <input id="localEndpoint" placeholder="http://127.0.0.1:8765/kev_ai/listener" />
    </label>
    <div class="row">
      <div>
        <label>Route Strategy
          <select id="routeStrategy">
            <option value="auto">auto</option>
            <option value="render">render</option>
            <option value="local">local</option>
            <option value="both">both</option>
          </select>
        </label>
      </div>
      <div>
        <label>Shared Secret
          <input id="sharedSecret" placeholder="optional but recommended" />
        </label>
      </div>
    </div>
    <button id="save">Save</button>
    <p class="muted">Use <code>target</code> in the command to steer routing when strategy=auto.</p>
    <script src="options.js"></script>
  </body>
</html>


############################
# extension/options.js
############################
const DEFAULTS = {
  renderEndpoint: 'https://hal-ku4c.onrender.com/kev_ai/listener',
  localEndpoint: 'http://127.0.0.1:8765/kev_ai/listener',
  sharedSecret: '',
  routeStrategy: 'auto'
};

function load() {
  chrome.storage.sync.get(DEFAULTS, (cfg) => {
    for (const k of Object.keys(DEFAULTS)) {
      document.getElementById(k).value = cfg[k];
    }
  });
}

function save() {
  const cfg = {};
  for (const k of Object.keys(DEFAULTS)) {
    cfg[k] = document.getElementById(k).value;
  }
  chrome.storage.sync.set(cfg, () => alert('Saved'));
}

document.getElementById('save').addEventListener('click', save);
window.addEventListener('DOMContentLoaded', load);


############################
# local_relay/requirements.txt
############################
fastapi==0.115.0
uvicorn[standard]==0.30.6
pydantic==2.9.2
python-multipart==0.0.10
pyyaml==6.0.2


############################
# local_relay/schemas.py
############################
from __future__ import annotations
from pydantic import BaseModel, Field
from typing import Any, Dict, Optional

class KevCommand(BaseModel):
    id: str = Field(..., description="deterministic id / hash")
    target: Optional[str] = Field(default="local")
    op: Optional[str] = Field(default=None, description="operation name like file_ops.write_file")
    args: Dict[str, Any] = Field(default_factory=dict)
    meta: Dict[str, Any] = Field(default_factory=dict)

class WrappedPayload(BaseModel):
    id: str
    raw: str
    parsed: KevCommand
    source: str
    ts: int


############################
# local_relay/security.py
############################
import hmac, hashlib, os
from typing import Optional

SECRET_ENV = "HAL_RELAY_SECRET"

def get_secret() -> Optional[str]:
    return os.getenv(SECRET_ENV)

def compute_hmac(secret: str, data: str) -> str:
    return hmac.new(secret.encode("utf-8"), data.encode("utf-8"), hashlib.sha256).hexdigest()

def verify(signature: Optional[str], raw: str) -> bool:
    secret = get_secret()
    if not secret:
        return True  # why: allow no-secret dev mode
    if not signature:
        return False
    expected = compute_hmac(secret, raw)
    # constant time compare
    return hmac.compare_digest(expected, signature)


############################
# local_relay/ssd.py
############################
from __future__ import annotations
import os
from pathlib import Path
from typing import Optional

DEFAULT_ENV = "HAL_SSD_ROOT"
LABEL_ENV = "HAL_SSD_LABEL"  # e.g., GENESIS

COMMON_MOUNTS = [
    Path("/Volumes"),           # macOS
    Path("/media"),             # Linux
    Path("/mnt"),               # WSL/Linux
]

WINDOWS_LETTERS = [f"{c}:/" for c in "DEFGHIJKLMNOPQRSTUVWXYZ"]


def _win_get_volume_label(root: str) -> Optional[str]:
    """Return Windows volume label for a drive like 'E:/' using ctypes (no deps)."""
    try:
        import ctypes
        from ctypes import wintypes as wt
        buf_name = ctypes.create_unicode_buffer(1024)
        fs_name = ctypes.create_unicode_buffer(1024)
        serial = wt.DWORD()
        max_comp_len = wt.DWORD()
        flags = wt.DWORD()
        ok = ctypes.windll.kernel32.GetVolumeInformationW(
            wt.LPCWSTR(root), buf_name, 1024, ctypes.byref(serial), ctypes.byref(max_comp_len),
            ctypes.byref(flags), fs_name, 1024
        )
        if ok:
            return buf_name.value or None
    except Exception:
        return None
    return None


def _prefer_label_path(label: str) -> Optional[Path]:
    # macOS/Linux: the mount point directory is typically the volume label
    for base in COMMON_MOUNTS:
        if not base.exists():
            continue
        candidate = base / label
        try:
            if candidate.exists() and candidate.is_dir() and os.access(candidate, os.W_OK):
                return candidate.resolve()
        except Exception:
            continue

    # Windows: check drive letters, read volume label
    if os.name == 'nt':
        for letter in WINDOWS_LETTERS:
            p = Path(letter)
            try:
                if not p.exists():
                    continue
                vol = _win_get_volume_label(letter)
                if vol and vol.strip().lower() == label.strip().lower() and os.access(p, os.W_OK):
                    return p.resolve()
            except Exception:
                continue
    return None


def resolve_root(explicit: Optional[str] = None, label: Optional[str] = None) -> Path:
    """Resolve SSD root. Order: explicit path > env HAL_SSD_ROOT > label match > first writable mount > cwd."""
    if explicit:
        return Path(explicit).expanduser().resolve()

    env = os.getenv(DEFAULT_ENV)
    if env:
        return Path(env).expanduser().resolve()

    label = label or os.getenv(LABEL_ENV) or None
    if label:
        preferred = _prefer_label_path(label)
        if preferred is not None:
            return preferred

    # fallback: first writable mount
    for base in COMMON_MOUNTS:
        if not base.exists():
            continue
        for child in base.iterdir():
            try:
                if child.is_dir() and os.access(child, os.W_OK):
                    return child.resolve()
            except Exception:
                continue

    if os.name == 'nt':
        for letter in WINDOWS_LETTERS:
            p = Path(letter)
            try:
                if p.exists() and os.access(p, os.W_OK):
                    return p.resolve()
            except Exception:
                continue

    return Path.cwd().resolve()


def safe_join(root: Path, rel_path: str) -> Path:
    candidate = (root / rel_path).expanduser()
    resolved = candidate.resolve()
    if not str(resolved).startswith(str(root)):
        raise PermissionError("Path escapes SSD root")
    return resolved

############################
from __future__ import annotations
import os
from pathlib import Path
from typing import Optional, Tuple

DEFAULT_ENV = "HAL_SSD_ROOT"

COMMON_MOUNTS = [
    Path("/Volumes"),           # macOS
    Path("/media"),             # Linux
    Path("/mnt"),               # WSL/Linux
]

WINDOWS_LETTERS = [f"{c}:/" for c in "DEFGHIJKLMNOPQRSTUVWXYZ"]


def resolve_root(explicit: Optional[str] = None) -> Path:
    if explicit:
        return Path(explicit).expanduser().resolve()
    env = os.getenv(DEFAULT_ENV)
    if env:
        return Path(env).expanduser().resolve()
    # try to autodetect a likely external drive
    # heuristic: first non-system mount with write access
    # macOS/Linux
    for base in COMMON_MOUNTS:
        if not base.exists():
            continue
        for child in base.iterdir():
            try:
                if child.is_dir() and os.access(child, os.W_OK):
                    return child.resolve()
            except Exception:
                continue
    # Windows
    if os.name == 'nt':
        for letter in WINDOWS_LETTERS:
            p = Path(letter)
            try:
                if p.exists() and os.access(p, os.W_OK):
                    return p.resolve()
            except Exception:
                continue
    # fallback: current directory
    return Path.cwd().resolve()


def safe_join(root: Path, rel_path: str) -> Path:
    candidate = (root / rel_path).expanduser()
    resolved = candidate.resolve()
    if not str(resolved).startswith(str(root)):
        raise PermissionError("Path escapes SSD root")
    return resolved


############################
# local_relay/app.py
############################
from __future__ import annotations
import argparse
import json
import os
from pathlib import Path
from typing import Any, Dict

from fastapi import FastAPI, Header, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

from .schemas import WrappedPayload, KevCommand
from .security import verify
from .ssd import resolve_root, safe_join

app = FastAPI(title="HAL Local Relay")

# CORS for the extension + local
app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "https://chat.openai.com", "https://chatgpt.com", "chrome-extension://*",
        "http://localhost", "http://localhost:*", "http://127.0.0.1", "http://127.0.0.1:*"
    ],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"]
)

STATE: Dict[str, Any] = {
    "ssd_root": None,
    "allow_run": False,
    "forward_render": os.getenv("HAL_RENDER_ENDPOINT")
}

class FileOp(BaseModel):
    path: str
    content: str | None = None
    encoding: str = "utf-8"

@app.get("/health")
async def health():
    root = STATE["ssd_root"]
    return {"ok": True, "ssd_root": str(root), "exists": Path(root).exists()}

@app.post("/kev_ai/listener")
async def kev_ai_listener(payload: WrappedPayload, x_kev_signature: str | None = Header(default=None)):
    if not verify(x_kev_signature, payload.raw):
        raise HTTPException(status_code=401, detail="signature invalid")

    cmd: KevCommand = payload.parsed
    target = (cmd.target or "local").lower()

    if target in ("local", "both"):
        return await handle_local(cmd)

    if target == "render":
        fwd = STATE.get("forward_render")
        if not fwd:
            return {"ok": False, "error": "no forward configured"}
        import urllib.request
        req = urllib.request.Request(fwd, data=json.dumps(payload.model_dump()).encode("utf-8"),
                                     headers={"Content-Type": "application/json", "X-KEV-Signature": x_kev_signature or ""},
                                     method="POST")
        try:
            with urllib.request.urlopen(req, timeout=20) as resp:
                return json.loads(resp.read().decode("utf-8"))
        except Exception as e:
            return {"ok": False, "error": str(e)}

    return {"ok": False, "error": f"unknown target {target}"}


async def handle_local(cmd: KevCommand):
    op = (cmd.op or "").lower()
    args = cmd.args or {}
    root: Path = STATE["ssd_root"]

    if op in ("file_ops.read_file", "read_file"):
        p = safe_join(root, args.get("path", ""))
        encoding = args.get("encoding", "utf-8")
        if not p.exists():
            return {"ok": False, "error": "file not found", "path": str(p)}
        data = p.read_text(encoding=encoding)
        return {"ok": True, "path": str(p), "content": data}

    if op in ("file_ops.write_file", "write_file"):
        p = safe_join(root, args.get("path", ""))
        p.parent.mkdir(parents=True, exist_ok=True)
        encoding = args.get("encoding", "utf-8")
        p.write_text(args.get("content", ""), encoding=encoding)
        return {"ok": True, "path": str(p), "bytes": p.stat().st_size}

    if op in ("file_ops.list_dir", "list_dir"):
        p = safe_join(root, args.get("path", "."))
        if not p.exists() or not p.is_dir():
            return {"ok": False, "error": "dir not found", "path": str(p)}
        items = []
        for child in sorted(p.iterdir()):
            items.append({"name": child.name, "is_dir": child.is_dir(), "size": (child.stat().st_size if child.is_file() else None)})
        return {"ok": True, "path": str(p), "items": items}

    if op in ("file_ops.delete_file", "delete_file"):
        p = safe_join(root, args.get("path", ""))
        if not p.exists():
            return {"ok": True, "path": str(p), "deleted": False}
        if p.is_dir():
            return {"ok": False, "error": "refusing to delete directory"}
        p.unlink()
        return {"ok": True, "path": str(p), "deleted": True}

    if op in ("file_ops.mkdirs", "mkdirs"):
        p = safe_join(root, args.get("path", ""))
        p.mkdir(parents=True, exist_ok=True)
        return {"ok": True, "path": str(p)}

    if op in ("system_control.run", "run_cmd"):
        if not STATE.get("allow_run"):
            return {"ok": False, "error": "run disabled; start with --allow-run"}
        import subprocess, shlex
        cmdline = args.get("cmd")
        if not cmdline:
            return {"ok": False, "error": "missing cmd"}
        try:
            out = subprocess.run(shlex.split(cmdline), capture_output=True, text=True, cwd=str(root), timeout=30)
            return {"ok": True, "code": out.returncode, "stdout": out.stdout, "stderr": out.stderr}
        except Exception as e:
            return {"ok": False, "error": str(e)}

    return {"ok": False, "error": f"unknown op {op}"}


def main():
    parser = argparse.ArgumentParser(description="HAL Local Relay")
    parser.add_argument("--host", default="127.0.0.1")
    parser.add_argument("--port", type=int, default=8765)
    parser.add_argument("--ssd-root", default=None, help="explicit SSD root path")
    parser.add_argument("--ssd-label", default=os.getenv("HAL_SSD_LABEL", None), help="prefer volume label (e.g., GENESIS)")
    parser.add_argument("--allow-run", action="store_true")
    args = parser.parse_args()

    STATE["ssd_root"] = resolve_root(args.ssd_root, label=args.ssd_label)
    STATE["allow_run"] = bool(args.allow_run)

    import uvicorn
    uvicorn.run("local_relay.app:app", host=args.host, port=args.port, reload=False)


if __name__ == "__main__":
    main()

############################
from __future__ import annotations
import argparse
import json
import os
from pathlib import Path
from typing import Any, Dict

from fastapi import FastAPI, Header, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

from .schemas import WrappedPayload, KevCommand
from .security import verify
from .ssd import resolve_root, safe_join

app = FastAPI(title="HAL Local Relay")

# CORS for the extension + local
app.add_middleware(
    CORSMiddleware,
    allow_origins=["https://chat.openai.com", "https://chatgpt.com", "chrome-extension://*", "http://localhost:*"," 
                   "http://127.0.0.1:*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"]
)

STATE: Dict[str, Any] = {
    "ssd_root": resolve_root(),
    "allow_run": False,
    "forward_render": os.getenv("HAL_RENDER_ENDPOINT")
}

class FileOp(BaseModel):
    path: str
    content: str | None = None
    encoding: str = "utf-8"

@app.get("/health")
async def health():
    root = STATE["ssd_root"]
    return {"ok": True, "ssd_root": str(root), "exists": Path(root).exists()}

@app.post("/kev_ai/listener")
async def kev_ai_listener(payload: WrappedPayload, x_kev_signature: str | None = Header(default=None)):
    if not verify(x_kev_signature, payload.raw):
        raise HTTPException(status_code=401, detail="signature invalid")

    cmd: KevCommand = payload.parsed
    target = (cmd.target or "local").lower()

    if target in ("local", "both"):
        return await handle_local(cmd)

    # optional forward to render if configured
    if target == "render":
        fwd = STATE.get("forward_render")
        if not fwd:
            return {"ok": False, "error": "no forward configured"}
        import urllib.request
        req = urllib.request.Request(fwd, data=json.dumps(payload.model_dump()).encode("utf-8"),
                                     headers={"Content-Type": "application/json", "X-KEV-Signature": x_kev_signature or ""},
                                     method="POST")
        try:
            with urllib.request.urlopen(req, timeout=20) as resp:
                return json.loads(resp.read().decode("utf-8"))
        except Exception as e:
            return {"ok": False, "error": str(e)}

    return {"ok": False, "error": f"unknown target {target}"}


async def handle_local(cmd: KevCommand):
    op = (cmd.op or "").lower()
    args = cmd.args or {}
    root: Path = STATE["ssd_root"]

    if op in ("file_ops.read_file", "read_file"):
        p = safe_join(root, args.get("path", ""))
        encoding = args.get("encoding", "utf-8")
        if not p.exists():
            return {"ok": False, "error": "file not found", "path": str(p)}
        data = p.read_text(encoding=encoding)
        return {"ok": True, "path": str(p), "content": data}

    if op in ("file_ops.write_file", "write_file"):
        p = safe_join(root, args.get("path", ""))
        p.parent.mkdir(parents=True, exist_ok=True)
        encoding = args.get("encoding", "utf-8")
        p.write_text(args.get("content", ""), encoding=encoding)
        return {"ok": True, "path": str(p), "bytes": p.stat().st_size}

    if op in ("file_ops.list_dir", "list_dir"):
        p = safe_join(root, args.get("path", "."))
        if not p.exists() or not p.is_dir():
            return {"ok": False, "error": "dir not found", "path": str(p)}
        items = []
        for child in sorted(p.iterdir()):
            items.append({"name": child.name, "is_dir": child.is_dir(), "size": (child.stat().st_size if child.is_file() else None)})
        return {"ok": True, "path": str(p), "items": items}

    if op in ("file_ops.delete_file", "delete_file"):
        p = safe_join(root, args.get("path", ""))
        if not p.exists():
            return {"ok": True, "path": str(p), "deleted": False}
        if p.is_dir():
            return {"ok": False, "error": "refusing to delete directory"}
        p.unlink()
        return {"ok": True, "path": str(p), "deleted": True}

    if op in ("file_ops.mkdirs", "mkdirs"):
        p = safe_join(root, args.get("path", ""))
        p.mkdir(parents=True, exist_ok=True)
        return {"ok": True, "path": str(p)}

    if op in ("system_control.run", "run_cmd"):
        if not STATE.get("allow_run"):
            return {"ok": False, "error": "run disabled; start with --allow-run"}
        import subprocess, shlex
        cmdline = args.get("cmd")
        if not cmdline:
            return {"ok": False, "error": "missing cmd"}
        try:
            out = subprocess.run(shlex.split(cmdline), capture_output=True, text=True, cwd=str(root), timeout=30)
            return {"ok": True, "code": out.returncode, "stdout": out.stdout, "stderr": out.stderr}
        except Exception as e:
            return {"ok": False, "error": str(e)}

    return {"ok": False, "error": f"unknown op {op}"}


def main():
    parser = argparse.ArgumentParser(description="HAL Local Relay")
    parser.add_argument("--host", default="127.0.0.1")
    parser.add_argument("--port", type=int, default=8765)
    parser.add_argument("--ssd-root", default=None, help="explicit SSD root")
    parser.add_argument("--allow-run", action="store_true")
    args = parser.parse_args()

    STATE["ssd_root"] = resolve_root(args.ssd_root)
    STATE["allow_run"] = bool(args.allow_run)

    import uvicorn
    uvicorn.run("local_relay.app:app", host=args.host, port=args.port, reload=False)


if __name__ == "__main__":
    main()


############################
# local_relay/README.md
############################
# HAL Local Relay

## Run

```bash
python -m venv .venv && . .venv/bin/activate
pip install -r local_relay/requirements.txt
export HAL_RELAY_SECRET="<same-as-extension>"
# Prefer your SSD by label (e.g., GENESIS):
export HAL_SSD_LABEL="GENESIS"
# or explicit path override:
# export HAL_SSD_ROOT="/Volumes/GENESIS"
python -m local_relay.app --ssd-label GENESIS
```

## Test

```bash
curl -sS -X POST http://127.0.0.1:8765/kev_ai/listener \
  -H 'Content-Type: application/json' \
  -H "X-KEV-Signature: $(python - <<'PY'
import hmac,hashlib,sys,json
secret='YOURSECRET'
raw='{"op":"file_ops.write_file"}'
print(hmac.new(secret.encode(), raw.encode(), hashlib.sha256).hexdigest())
PY
)" \
  -d '{"id":"demo","raw":"{\"op\":\"file_ops.write_file\",\"args\":{\"path\":\"memory/short_term/seed.json\",\"content\":\"hello\"}}","parsed":{"id":"demo","target":"local","op":"file_ops.write_file","args":{"path":"memory/short_term/seed.json","content":"hello"}},"source":"test","ts":0}'
```

## Example ChatGPT block

```
[KEV_AI::command]
{
  "id": "seed-write-001",
  "target": "local",
  "op": "file_ops.write_file",
  "args": {
    "path": "memory/short_term/seed.json",
    "content": "{\"ok\":true}"
  },
  "meta": {"note": "write to portable SSD"}
}
[/KEV_AI::command]
```
```bash
python -m venv .venv && . .venv/bin/activate
pip install -r local_relay/requirements.txt
export HAL_RELAY_SECRET="<same-as-extension>"
# optional: export HAL_SSD_ROOT="/Volumes/YourSSD"
python -m local_relay.app --ssd-root /Volumes/PORTABLE_SSD
```

## Test

```bash
curl -sS -X POST http://127.0.0.1:8765/kev_ai/listener \
  -H 'Content-Type: application/json' \
  -H "X-KEV-Signature: $(python - <<'PY'\nimport hmac,hashlib,sys,json\nsecret='YOURSECRET'\nraw='{"op":"file_ops.write_file"}'\nprint(hmac.new(secret.encode(), raw.encode(), hashlib.sha256).hexdigest())\nPY
)" \
  -d '{"id":"demo","raw":"{\\"op\\":\\"file_ops.write_file\\",\\"args\\":{\\"path\\":\\"memory/short_term/seed.json\\",\\"content\\":\\"hello\\"}}","parsed":{"id":"demo","target":"local","op":"file_ops.write_file","args":{"path":"memory/short_term/seed.json","content":"hello"}},"source":"test","ts":0}'
```

## Example ChatGPT block

```
[KEV_AI::command]
{
  "id": "seed-write-001",
  "target": "local",
  "op": "file_ops.write_file",
  "args": {
    "path": "memory/short_term/seed.json",
    "content": "{\"ok\":true}"
  },
  "meta": {"note": "write to portable SSD"}
}
[/KEV_AI::command]


############################
# command_catalog/command_schema.json
############################
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "KevAICommand",
  "type": "object",
  "required": ["id", "target", "op", "args"],
  "properties": {
    "id": { "type": "string", "description": "deterministic id or UUID" },
    "target": { "type": "string", "enum": ["local", "render", "both"] },
    "op": { "type": "string", "description": "operation name, e.g. file_ops.write_file" },
    "args": { "type": "object", "additionalProperties": true },
    "meta": { "type": "object", "additionalProperties": true }
  },
  "additionalProperties": false
}


############################
# command_catalog/catalog.json
############################
{
  "version": "1.0.0",
  "commands": [
    {
      "name": "file_ops.read_file",
      "target": "local",
      "args": {
        "path": {"type": "string", "required": true},
        "encoding": {"type": "string", "required": false, "default": "utf-8"}
      },
      "description": "Read a file from the SSD root"
    },
    {
      "name": "file_ops.write_file",
      "target": "local",
      "args": {
        "path": {"type": "string", "required": true},
        "content": {"type": "string", "required": true},
        "encoding": {"type": "string", "required": false, "default": "utf-8"}
      },
      "description": "Write text to a file under SSD root (creates dirs)"
    },
    {
      "name": "file_ops.list_dir",
      "target": "local",
      "args": {
        "path": {"type": "string", "required": false, "default": "."}
      },
      "description": "List directory entries"
    },
    {
      "name": "file_ops.mkdirs",
      "target": "local",
      "args": {
        "path": {"type": "string", "required": true}
      },
      "description": "Create directories recursively"
    },
    {
      "name": "file_ops.delete_file",
      "target": "local",
      "args": {
        "path": {"type": "string", "required": true}
      },
      "description": "Delete a single file (no recursive delete)"
    },
    {
      "name": "system_control.run",
      "target": "local",
      "args": {
        "cmd": {"type": "string", "required": true}
      },
      "description": "Run a shell command in SSD root (requires --allow-run)"
    },
    {
      "name": "github.get_file",
      "target": "render",
      "args": {
        "repo": {"type": "string", "required": true},
        "path": {"type": "string", "required": true},
        "ref": {"type": "string", "required": false, "default": "main"}
      },
      "description": "Fetch a file via Render HAL github router"
    },
    {
      "name": "github.put_file",
      "target": "render",
      "args": {
        "repo": {"type": "string", "required": true},
        "path": {"type": "string", "required": true},
        "content": {"type": "string", "required": true},
        "message": {"type": "string", "required": true}
      },
      "description": "Commit a file via Render HAL github router"
    },
    {
      "name": "memory_ops.save_memory",
      "target": "render",
      "args": {
        "scope": {"type": "string", "required": true, "enum": ["short_term", "mid_term", "long_term"]},
        "path": {"type": "string", "required": true},
        "content": {"type": "string", "required": true}
      },
      "description": "Save a memory document on Render"
    },
    {
      "name": "memory_ops.restore_memory",
      "target": "render",
      "args": {
        "scope": {"type": "string", "required": true},
        "path": {"type": "string", "required": true}
      },
      "description": "Restore a memory document from Render"
    },
    {
      "name": "echo",
      "target": "render",
      "args": {"payload": {"type": "string", "required": false}},
      "description": "Connectivity check"
    }
  ]
}


############################
# command_catalog/command_catalog.md
############################
# HAL Command Catalog (for Chat Blocks)

Place commands inside ChatGPT messages using:

```
[KEV_AI::command]
{ ...command json... }
[/KEV_AI::command]
```

## Local SSD Ops

### Read file
```
{ "id": "read-001", "target": "local", "op": "file_ops.read_file", "args": { "path": "projects/alpha/main.py" } }
```

### Write file (Python)
```
{ "id": "write-001", "target": "local", "op": "file_ops.write_file", "args": { "path": "projects/alpha/main.py", "content": "print('hello')
" } }
```

### List dir
```
{ "id": "ls-001", "target": "local", "op": "file_ops.list_dir", "args": { "path": "projects/alpha" } }
```

### Make dirs
```
{ "id": "mk-001", "target": "local", "op": "file_ops.mkdirs", "args": { "path": "projects/alpha" } }
```

### Delete file
```
{ "id": "rm-001", "target": "local", "op": "file_ops.delete_file", "args": { "path": "projects/alpha/tmp.txt" } }
```

### Run command (disabled unless started with --allow-run)
```
{ "id": "run-001", "target": "local", "op": "system_control.run", "args": { "cmd": "python3 projects/alpha/main.py" } }
```

## Render (GitHub/Memory) Ops

### GitHub: get file
```
{ "id": "gh-get-001", "target": "render", "op": "github.get_file", "args": { "repo": "Demigodofa/hal", "path": "README.md", "ref": "main" } }
```

### GitHub: put file
```
{ "id": "gh-put-001", "target": "render", "op": "github.put_file", "args": { "repo": "Demigodofa/hal", "path": "memory/short_term/seed.json", "content": "{\"ok\":true}
", "message": "chore: seed" } }
```

### Memory: save
```
{ "id": "mem-save-001", "target": "render", "op": "memory_ops.save_memory", "args": { "scope": "short_term", "path": "seed.json", "content": "{\"n\":1}" } }
```

### Memory: restore
```
{ "id": "mem-restore-001", "target": "render", "op": "memory_ops.restore_memory", "args": { "scope": "short_term", "path": "seed.json" } }
```

### Echo
```
{ "id": "echo-001", "target": "render", "op": "echo", "args": { "payload": "ping" } }
```

## Dual-target example
```
{ "id": "dual-001", "target": "both", "op": "file_ops.list_dir", "args": { "path": "." } }
```


############################
# examples/commands/read_python_file.json
############################
{
  "id": "read-py-001",
  "target": "local",
  "op": "file_ops.read_file",
  "args": { "path": "projects/demo/app.py", "encoding": "utf-8" }
}


############################
# examples/commands/write_python_file.json
############################
{
  "id": "write-py-001",
  "target": "local",
  "op": "file_ops.write_file",
  "args": { "path": "projects/demo/app.py", "content": "print('hi')
" }
}


############################
# examples/commands/list_project_root.json
############################
{
  "id": "ls-root-001",
  "target": "local",
  "op": "file_ops.list_dir",
  "args": { "path": "." }
}


############################
# examples/commands/mkdir_project_dir.json
############################
{
  "id": "mkdir-001",
  "target": "local",
  "op": "file_ops.mkdirs",
  "args": { "path": "projects/demo" }
}


############################
# examples/commands/delete_file.json
############################
{
  "id": "rm-file-001",
  "target": "local",
  "op": "file_ops.delete_file",
  "args": { "path": "projects/demo/app.py" }
}


############################
# examples/commands/run_cmd_pip_freeze.json
############################
{
  "id": "run-cmd-001",
  "target": "local",
  "op": "system_control.run",
  "args": { "cmd": "pip freeze" }
}


############################
# examples/commands/git_get_file_render.json
############################
{
  "id": "gh-get-001",
  "target": "render",
  "op": "github.get_file",
  "args": { "repo": "Demigodofa/hal", "path": "README.md", "ref": "main" }
}


############################
# examples/commands/git_put_file_render.json
############################
{
  "id": "gh-put-001",
  "target": "render",
  "op": "github.put_file",
  "args": { "repo": "Demigodofa/hal", "path": "memory/short_term/seed.json", "content": "{\"seed\":true}
", "message": "chore: seed" }
}


############################
# examples/commands/memory_save_render.json
############################
{
  "id": "mem-save-001",
  "target": "render",
  "op": "memory_ops.save_memory",
  "args": { "scope": "short_term", "path": "seed.json", "content": "{\"hello\":\"world\"}" }
}


############################
# pack.sh
############################
#!/usr/bin/env bash
set -euo pipefail
ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
OUT="${1:-hal-relay.zip}"
TMP="$(mktemp -d)"
trap 'rm -rf "$TMP"' EXIT
mkdir -p "$TMP/hal-relay"
rsync -a --delete --exclude '.git' --exclude '*.zip' \
  "$ROOT/extension" "$ROOT/local_relay" "$ROOT/command_catalog" "$ROOT/examples" \
  "$ROOT/README.md" \
  "$TMP/hal-relay/"
( cd "$TMP" && zip -r "$OUT" "hal-relay" >/dev/null )
mv "$TMP/$OUT" "$ROOT/"
echo "Wrote $ROOT/$OUT"


############################
# pack.ps1
############################
Param([string]$Out = "hal-relay.zip")
$root = Split-Path -Parent $MyInvocation.MyCommand.Path
$dest = Join-Path $root $Out
if (Test-Path $dest) { Remove-Item $dest }
$staging = Join-Path $env:TEMP ("hal-relay-" + [guid]::NewGuid())
New-Item $staging -ItemType Directory | Out-Null
Copy-Item -Recurse -Force "$root/extension","$root/local_relay","$root/command_catalog","$root/examples","$root/README.md" $staging
Add-Type -AssemblyName 'System.IO.Compression.FileSystem'
[System.IO.Compression.ZipFile]::CreateFromDirectory($staging, $dest)
Remove-Item -Recurse -Force $staging
Write-Host "Wrote $dest"


############################
# .gitignore (suggested)
############################
*.zip
.venv/
__pycache__/



############################
# web_relay/index.html (Zero‑install browser relay using File System Access API)
############################
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>HAL Web Relay (Local SSD + Render)</title>
  <style>
    :root { --fg:#0f172a; --muted:#475569; --bg:#f8fafc; --card:#ffffff; --ok:#16a34a; --err:#dc2626; --warn:#d97706; }
    html,body{height:100%}
    body{margin:0;font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Arial;background:var(--bg);color:var(--fg)}
    .wrap{max-width:960px;margin:24px auto;padding:0 16px}
    .card{background:var(--card);border-radius:16px;box-shadow:0 4px 14px rgba(2,6,23,.06);padding:16px 16px}
    h1{font-size:22px;margin:0 0 12px}
    h2{font-size:18px;margin:16px 0 8px}
    label{display:block;font-size:12px;color:var(--muted);margin:8px 0 4px}
    input,textarea,button,select{font:inherit}
    input,textarea,select{width:100%;box-sizing:border-box;padding:10px 12px;border:1px solid #e5e7eb;border-radius:10px;background:#fff}
    textarea{min-height:140px;resize:vertical}
    .row{display:flex;gap:12px;align-items:flex-end}
    .row>.col{flex:1}
    .btn{padding:10px 14px;border:none;border-radius:12px;background:#111827;color:#fff;cursor:pointer}
    .btn.alt{background:#334155}
    .btn.ok{background:var(--ok)}
    .btn.warn{background:var(--warn)}
    .btn.err{background:var(--err)}
    .muted{color:var(--muted);font-size:12px}
    .badge{display:inline-flex;align-items:center;gap:6px;padding:4px 8px;border-radius:999px;background:#eef2ff;color:#3730a3;font-size:12px}
    .log{font-family:ui-monospace,SFMono-Regular,Menlo,monospace;background:#0b1020;color:#e5e7eb;border-radius:12px;padding:12px;height:240px;overflow:auto;white-space:pre-wrap}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,monospace}
    .kbd{font-family:ui-monospace,monospace;background:#e5e7eb;border-radius:6px;padding:2px 6px}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>HAL Web Relay <span class="badge" id="status-badge">idle</span></h1>
      <p class="muted">Zero‑install bridge. Paste <span class="kbd">[KEV_AI::command]</span> blocks or JSON. Read/write your external SSD via the browser (Chromium). Forward cloud ops to Render.</p>

      <div class="grid">
        <div class="card" style="padding:12px">
          <h2>Local SSD</h2>
          <div class="row">
            <div class="col">
              <label>Chosen root</label>
              <input id="ssdLabel" class="mono" placeholder="Not connected" disabled />
            </div>
            <div>
              <button class="btn" id="pickBtn">Choose Folder</button>
            </div>
          </div>
          <p class="muted">Tip: Select the top folder on your drive (e.g. <strong>GENESIS</strong>). Letters don’t matter.</p>
        </div>

        <div class="card" style="padding:12px">
          <h2>Render Endpoint</h2>
          <label>Listener URL</label>
          <input id="renderUrl" value="https://hal-ku4c.onrender.com/kev_ai/listener" />
          <label>Shared Secret (HMAC)</label>
          <input id="sharedSecret" type="password" placeholder="optional but recommended" />
        </div>
      </div>

      <h2>Command</h2>
      <textarea id="cmdInput" spellcheck="false" placeholder="Paste [KEV_AI::command]…[/KEV_AI::command] or raw JSON here"></textarea>
      <div class="row" style="margin-top:8px">
        <div class="col">
          <button class="btn ok" id="runOnce">Process Once</button>
          <button class="btn alt" id="watchClipboard">Watch Clipboard</button>
          <button class="btn warn" id="importFromHash">Import From URL</button>
          <button class="btn" id="clearLog">Clear Log</button>
        </div>
        <div>
          <label>Mode</label>
          <select id="routeMode">
            <option value="auto" selected>auto</option>
            <option value="local">local</option>
            <option value="render">render</option>
            <option value="both">both</option>
          </select>
        </div>
      </div>

      <h2>Log</h2>
      <div class="log" id="log"></div>
      <p class="muted">Limitations: Browser cannot run shell locally (we ignore <code>system_control.run</code> on local). Use Render for those. Firefox/Safari support for File System Access API varies; Chromium recommended.</p>

      <h2>Bookmarklet (optional)</h2>
      <p class="muted">Create a bookmark with the URL from <em>bookmarklet.txt</em>. Click it on ChatGPT to send the latest block to this page (opens new tab).</p>
    </div>
  </div>

  <script>
    // Utilities
    const $ = (s) => document.querySelector(s);
    const logEl = $('#log');
    const statusBadge = $('#status-badge');
    const setStatus = (t) => statusBadge.textContent = t;
    const log = (...a) => { const line = a.map(v => typeof v==='string'? v : JSON.stringify(v, null, 2)).join(' '); logEl.textContent += `
${line}`; logEl.scrollTop = logEl.scrollHeight; };

    // State
    let ssdRoot = null; // FileSystemDirectoryHandle
    let watchTimer = null;

    // Persist simple settings
    const SETTINGS_KEY = 'hal-web-relay-settings';
    const loadSettings = () => { try { return JSON.parse(localStorage.getItem(SETTINGS_KEY) || '{}'); } catch { return {}; } };
    const saveSettings = (obj) => localStorage.setItem(SETTINGS_KEY, JSON.stringify(obj));

    const settings = loadSettings();
    if (settings.renderUrl) $('#renderUrl').value = settings.renderUrl;
    if (settings.sharedSecret) $('#sharedSecret').value = settings.sharedSecret;
    if (settings.mode) $('#routeMode').value = settings.mode;

    $('#renderUrl').addEventListener('input', () => { settings.renderUrl = $('#renderUrl').value; saveSettings(settings); });
    $('#sharedSecret').addEventListener('input', () => { settings.sharedSecret = $('#sharedSecret').value; saveSettings(settings); });
    $('#routeMode').addEventListener('change', () => { settings.mode = $('#routeMode').value; saveSettings(settings); });

    // FS helpers
    function splitPath(p) {
      return String(p).split('/').filter(Boolean).filter(seg => seg !== '.' && seg !== '..');
    }

    async function ensureDir(root, relPath) {
      const parts = splitPath(relPath);
      let dir = root;
      for (const part of parts) {
        dir = await dir.getDirectoryHandle(part, { create: true });
      }
      return dir;
    }

    async function getParentDir(root, relPath, create=false) {
      const parts = splitPath(relPath);
      if (parts.length === 0) throw new Error('empty path');
      let dir = root;
      for (let i=0; i<parts.length-1; i++) {
        dir = await dir.getDirectoryHandle(parts[i], { create });
      }
      return { dir, name: parts[parts.length-1] };
    }

    async function writeFile(root, relPath, content) {
      const { dir, name } = await getParentDir(root, relPath, true);
      const fh = await dir.getFileHandle(name, { create: true });
      const w = await fh.createWritable();
      await w.write(content);
      await w.close();
      return { path: relPath, bytes: content.length };
    }

    async function readFile(root, relPath) {
      const { dir, name } = await getParentDir(root, relPath, false);
      const fh = await dir.getFileHandle(name, { create: false });
      const file = await fh.getFile();
      const text = await file.text();
      return { path: relPath, content: text };
    }

    async function listDir(root, relPath='.') {
      const dir = relPath==='.' ? root : await ensureDir(root, relPath); // ensureDir throws if path not exists when create=false; we used create=true, but we need existence check
      const items = [];
      for await (const [name, handle] of dir.entries()) {
        const item = { name, is_dir: handle.kind === 'directory' };
        if (handle.kind === 'file') {
          const f = await handle.getFile();
          item.size = f.size;
        }
        items.push(item);
      }
      return { path: relPath, items };
    }

    async function deleteFile(root, relPath) {
      const { dir, name } = await getParentDir(root, relPath, false);
      await dir.removeEntry(name, { recursive: false });
      return { path: relPath, deleted: true };
    }

    // HMAC
    async function hmacSHA256(key, message) {
      if (!key) return undefined;
      const enc = new TextEncoder();
      const cryptoKey = await crypto.subtle.importKey('raw', enc.encode(key), { name: 'HMAC', hash: 'SHA-256' }, false, ['sign']);
      const sig = await crypto.subtle.sign('HMAC', cryptoKey, enc.encode(message));
      return Array.from(new Uint8Array(sig)).map(b => b.toString(16).padStart(2, '0')).join('');
    }

    // Render post
    async function postRender(url, secret, body) {
      const signature = await hmacSHA256(secret, body.raw);
      const res = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', ...(signature ? { 'X-KEV-Signature': signature } : {}) },
        body: JSON.stringify(body)
      });
      const json = await res.json().catch(() => ({}));
      return { ok: res.ok, status: res.status, json };
    }

    function extractBlock(text) {
      const start = text.indexOf('[KEV_AI::command]');
      const end = text.indexOf('[/KEV_AI::command]');
      if (start !== -1 && end !== -1 && end > start) {
        return text.slice(start + '[KEV_AI::command]'.length, end).trim();
      }
      return text.trim();
    }

    async function processOne(rawText) {
      try {
        const raw = extractBlock(rawText);
        const parsed = JSON.parse(raw);
        const id = parsed.id || Math.random().toString(36).slice(2);
        const target = (parsed.target || 'local').toLowerCase();
        const mode = $('#routeMode').value;
        const effective = mode === 'auto' ? target : mode; // local|render|both
        const body = { id, raw, parsed, source: 'web-relay', ts: Date.now() };

        let localDone = false, renderDone = false;

        if ((effective === 'local' || effective === 'both') && ssdRoot) {
          localDone = true;
          const op = (parsed.op || '').toLowerCase();
          const a = parsed.args || {};
          if (op === 'file_ops.read_file' || op === 'read_file') {
            const res = await readFile(ssdRoot, a.path);
            log('local read_file ok:', res);
          } else if (op === 'file_ops.write_file' || op === 'write_file') {
            const res = await writeFile(ssdRoot, a.path, a.content || '');
            log('local write_file ok:', res);
          } else if (op === 'file_ops.list_dir' || op === 'list_dir') {
            const res = await listDir(ssdRoot, a.path || '.');
            log('local list_dir ok:', res);
          } else if (op === 'file_ops.mkdirs' || op === 'mkdirs') {
            await ensureDir(ssdRoot, a.path);
            log('local mkdirs ok:', { path: a.path });
          } else if (op === 'file_ops.delete_file' || op === 'delete_file') {
            const res = await deleteFile(ssdRoot, a.path);
            log('local delete_file ok:', res);
          } else if (op === 'system_control.run' || op === 'run_cmd') {
            log('local run_cmd ignored in browser');
          } else {
            log('local unknown op:', op);
          }
        } else if ((effective === 'local' || effective === 'both') && !ssdRoot) {
          log('local: no SSD selected');
        }

        if (effective === 'render' || effective === 'both' || (effective === 'local' && target === 'render')) {
          renderDone = true;
          const rurl = $('#renderUrl').value.trim();
          const secret = $('#sharedSecret').value.trim();
          const res = await postRender(rurl, secret, body);
          log('render response:', res.status, res.json);
        }

        setStatus(`${localDone? 'local ' : ''}${renderDone? 'render' : ''}`.trim() || 'idle');
      } catch (e) {
        log('error:', e.message || e);
        setStatus('error');
      }
    }

    $('#runOnce').addEventListener('click', () => processOne($('#cmdInput').value));

    $('#watchClipboard').addEventListener('click', async (ev) => {
      if (watchTimer) { clearInterval(watchTimer); watchTimer = null; ev.target.textContent='Watch Clipboard'; return; }
      try {
        await navigator.permissions.query({ name: 'clipboard-read' });
      } catch {}
      ev.target.textContent='Watching…';
      let last = '';
      watchTimer = setInterval(async () => {
        try {
          const t = await navigator.clipboard.readText();
          if (t && t !== last && t.includes('KEV_AI::command')) {
            last = t;
            $('#cmdInput').value = t;
            log('clipboard captured block');
            processOne(t);
          }
        } catch {}
      }, 1500);
    });

    $('#importFromHash').addEventListener('click', () => {
      const h = location.hash.slice(1);
      const m = new URLSearchParams(h).get('payload');
      if (m) {
        try {
          const raw = atob(decodeURIComponent(m));
          $('#cmdInput').value = raw;
          log('imported from URL hash');
        } catch {}
      }
    });

    $('#clearLog').addEventListener('click', () => { logEl.textContent=''; setStatus('idle'); });

    $('#pickBtn').addEventListener('click', async () => {
      try {
        ssdRoot = await window.showDirectoryPicker();
        $('#ssdLabel').value = ssdRoot.name || '(selected)';
        if (ssdRoot.name && ssdRoot.name.toUpperCase() !== 'GENESIS') {
          log('warning: picked directory name != GENESIS');
        }
        setStatus('local ready');
      } catch (e) {
        log('pick canceled');
      }
    });

    // Accept payload via postMessage from bookmarklet
    window.addEventListener('message', (ev) => {
      if (!ev.data || typeof ev.data !== 'object') return;
      if (ev.data.type === 'HAL_PAYLOAD' && typeof ev.data.raw === 'string') {
        $('#cmdInput').value = ev.data.raw;
        log('received payload from bookmarklet');
      }
    });

    // Auto-import from URL hash on load
    window.addEventListener('DOMContentLoaded', () => {
      const h = location.hash.slice(1);
      const m = new URLSearchParams(h).get('payload');
      if (m) {
        try {
          const raw = atob(decodeURIComponent(m));
          $('#cmdInput').value = raw;
          log('imported from URL');
        } catch {}
      }
    });
  </script>
</body>
</html>


############################
# web_relay/bookmarklet.txt (Copy this into a bookmark's URL field)
############################
javascript:(function(){try{var MARK_S='[KEV_AI::command]',MARK_E='[/KEV_AI::command]';var blocks=document.querySelectorAll('pre,code,.markdown');var raw=null;for(var i=0;i<blocks.length;i++){var t=blocks[i].innerText||'';var s=t.indexOf(MARK_S),e=t.indexOf(MARK_E);if(s!=-1&&e!=-1&&e>s){raw=t.slice(s+MARK_S.length,e).trim();break;}}if(!raw){alert('No [KEV_AI::command] block found on this page.');return;}var payload=encodeURIComponent(btoa(raw));var relay='WEB_RELAY_URL_HERE';window.open(relay+'#payload='+payload,'_blank');}catch(e){alert('bookmarklet error: '+e.message)}})();


############################
# web_relay/README.md
############################
# HAL Web Relay (Zero‑install)

A single static page that:
- Reads/writes your external drive via the **File System Access API** (Chromium browsers).
- Forwards cloud commands to your Render listener with optional HMAC signature.
- Accepts pasted `[KEV_AI::command]` blocks, clipboard watch, URL hash, or bookmarklet `postMessage`.

## Host it
- **GitHub Pages:** place `web_relay/` in your repo and enable Pages → deploy from `/web_relay` or root.
- **Render (static):** serve `index.html` as a static file from your FastAPI app (optional).

## Use it
1. Open the page.
2. Click **Choose Folder** and select the root folder on your SSD (e.g. `GENESIS`). Letters don’t matter.
3. Paste a command (see catalog) and click **Process Once**.
4. Optional: set Render URL + Secret to forward render commands.

## Bookmarklet
- Edit `web_relay/bookmarklet.txt`: replace `WEB_RELAY_URL_HERE` with your hosted relay URL.
- Create a browser bookmark, set its URL to the full `javascript:...` text.
- On ChatGPT: click the bookmark; it opens the relay with the command pre‑filled.

## Limitations
- Browsers cannot run local shell commands. Use `target: "render"` for `system_control.run`.
- The page cannot auto‑discover drives; you must pick the folder once per session.
- File System Access API support: Chromium recommended. Firefox/Safari are partial/experimental.


############################
# Update pack scripts to include web_relay
############################
# (append to pack.sh content)
# Already handled by rsync if folder exists; no change needed.

# (append to pack.ps1 content)
# Already handled by Copy-Item if folder exists; no change needed.


############################
# openapi/hal-actions.yaml (for a Custom GPT Action – no extension/relay)
############################
openapi: 3.1.0
info:
  title: HAL Actions API
  version: 1.0.0
  description: |
    Minimal schema so a Custom GPT can POST commands directly to your Render HAL.
    Uses a single endpoint that accepts the existing wrapper shape `{id, raw, parsed, source, ts}`.
servers:
  - url: https://hal-ku4c.onrender.com
paths:
  /kev_ai/listener:
    post:
      operationId: postKevAiListener
      summary: Dispatch a HAL command
      security:
        - bearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/WrappedPayload'
      responses:
        '200':
          description: Result from HAL
          content:
            application/json:
              schema:
                type: object
components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
  schemas:
    KevCommand:
      type: object
      required: [id, target, op, args]
      properties:
        id: { type: string }
        target: { type: string, enum: [local, render, both] }
        op: { type: string }
        args: { type: object }
        meta: { type: object, additionalProperties: true }
    WrappedPayload:
      type: object
      required: [id, raw, parsed, source, ts]
      properties:
        id: { type: string }
        raw: { type: string, description: 'raw JSON of KevCommand' }
        parsed: { $ref: '#/components/schemas/KevCommand' }
        source: { type: string, example: 'chatgpt-actions' }
        ts: { type: integer, description: 'epoch millis' }


############################
# ACTIONS_SETUP.md (how to wire this with a Custom GPT)
############################
# Use ChatGPT Actions (no local relay)

1) In ChatGPT → **Explore GPTs** → **Create** → **Configure** → **Actions** → **Add Action**.
2) Paste the OpenAPI file from `openapi/hal-actions.yaml`.
3) **Auth**: choose **API Key** and map it to the header `Authorization` with value `Bearer {api_key}`.
   - Set the key to a long random token and save it as `HAL_LISTENER_TOKEN` on your Render app.
4) On your FastAPI app, protect `/kev_ai/listener` by checking this bearer token (snippet below).
5) Talk to your GPT: it will infer when to call the action and send the JSON wrapper.

## FastAPI bearer check (drop-in snippet)

```python
# app/security_bearer.py
import os
from fastapi import Header, HTTPException

TOKEN_ENV = 'HAL_LISTENER_TOKEN'

def verify_bearer(authorization: str | None = Header(default=None)):
    expected = os.getenv(TOKEN_ENV)
    if not expected:
        return  # dev/no-auth mode
    if not authorization or not authorization.startswith('Bearer '):
        raise HTTPException(status_code=401, detail='missing bearer')
    token = authorization.split(' ', 1)[1]
    if token != expected:
        raise HTTPException(status_code=403, detail='invalid bearer')
```

```python
# app/kev_ai_router.py (example usage)
from fastapi import APIRouter, Depends
from pydantic import BaseModel
from app.security_bearer import verify_bearer

class KevCommand(BaseModel):
    id: str
    target: str
    op: str
    args: dict
    meta: dict | None = None

class WrappedPayload(BaseModel):
    id: str
    raw: str
    parsed: KevCommand
    source: str
    ts: int

router = APIRouter(prefix='/kev_ai')

@router.post('/listener', dependencies=[Depends(verify_bearer)])
async def listener(payload: WrappedPayload):
    # TODO: call your existing dispatch to echo/file_ops/memory_ops/github/autonomy
    # return the dispatched result
    return {"ok": True, "received": payload.model_dump()}
```

```python
# app/main.py (ensure router is included)
from fastapi import FastAPI
from app.kev_ai_router import router as kev_router

app = FastAPI()
app.include_router(kev_router)
```

## Example payload the GPT will send
```
{
  "id": "write-001",
  "raw": "{
  \"id\": \"write-001\",
  \"target\": \"render\",
  \"op\": \"github.put_file\",
  \"args\": {
    \"repo\": \"Demigodofa/hal\",
    \"path\": \"memory/short_term/seed.json\",
    \"content\": \"{\\"seed\\":true}\n\",
    \"message\": \"chore: seed\"
  }
}",
  "parsed": {
    "id": "write-001",
    "target": "render",
    "op": "github.put_file",
    "args": {"repo": "Demigodofa/hal", "path": "memory/short_term/seed.json", "content": "{\"seed\":true}
", "message": "chore: seed"}
  },
  "source": "chatgpt-actions",
  "ts": 1690000000000
}
```

## Notes
- Actions run server-side from OpenAI; they can call your Render URL directly. No extension/relay required.
- Local SSD access is not possible from Actions; the browser‑only **web_relay** remains the only no‑install way to touch the SSD due to sandbox rules.


############################
# NOTES.md (Drive letters, GENESIS, and constraints)
############################
- **Drive letters don’t matter** when using the browser picker. Choose the folder named **GENESIS** once per session.
- **Auto-discovery** of a drive by name is not allowed from web pages; you must click a picker (user gesture) and be on HTTPS. (See MDN and Chrome docs.)
- **No background local access** from ChatGPT itself; only two compliant paths exist:
  1) **Custom GPT Action → Render** for all cloud operations.
  2) **Web relay page** you host (GitHub Pages/Render) for local SSD via File System Access.


############################
# windows/bootstrap_to_genesis.ps1  (one‑shot: creates everything on the GENESIS SSD)
############################
Param(
  [string]$Label = 'GENESIS',
  [string]$Base = 'HalRelay'
)
Set-StrictMode -Version Latest
$ErrorActionPreference = 'Stop'

function Find-Genesis {
  try { $v = Get-Volume -FileSystemLabel $Label | Select-Object -First 1 } catch { $v = $null }
  if (-not $v) {
    try { $w = Get-WmiObject Win32_Volume -Filter "Label='$Label'" | Select-Object -First 1; if ($w -and $w.DriveLetter) { return $w.DriveLetter.TrimEnd(':') } } catch {}
  }
  if ($v -and $v.DriveLetter) { return $v.DriveLetter }
  throw "Drive with label '$Label' not found."
}

function Ensure-Dir([string]$Path) { if (-not (Test-Path $Path)) { New-Item -ItemType Directory -Path $Path | Out-Null } }
function Write-Text([string]$Path,[string]$Content) {
  Ensure-Dir (Split-Path -Parent $Path)
  Set-Content -Path $Path -Value $Content -Encoding UTF8
}

$drive = (Find-Genesis)
$root  = Join-Path ("$drive`:") (Join-Path $Base 'hal-relay')
Ensure-Dir $root

# --- FILES ---
$files = @{
  'extension/manifest.json' = @'
{
  "manifest_version": 3,
  "name": "HAL Relay: ChatGPT → HAL",
  "version": "0.1.0",
  "description": "Detect [KEV_AI::command] blocks in ChatGPT and forward to HAL endpoints (Render/local).",
  "permissions": ["storage", "activeTab", "scripting"],
  "host_permissions": [
    "https://chat.openai.com/*",
    "https://*.openai.com/*",
    "https://hal-ku4c.onrender.com/*",
    "http://127.0.0.1/*",
    "http://localhost/*"
  ],
  "content_scripts": [
    {"matches": ["https://chat.openai.com/*", "https://chatgpt.com/*"],"js": ["content.js"],"run_at": "document_idle"}
  ],
  "background": { "service_worker": "service_worker.js" },
  "options_page": "options.html"
}
'@;
  'extension/content.js' = @'
(function () {
  const MARK_START = "[KEV_AI::command]";
  const MARK_END = "[/KEV_AI::command]";
  const findBlocks = (root) => { const out = []; root.querySelectorAll('pre, code, .markdown').forEach(n=>{const t=n.innerText; if(!t) return; const s=t.indexOf(MARK_START), e=t.indexOf(MARK_END); if(s!=-1&&e!=-1&&e>s){ out.push({node:n, raw:t.slice(s+MARK_START.length,e).trim()}); }}); return out; };
  const tag=(n,st,tt)=>{ n.style.outline= st==='sent'?'2px solid #22c55e': st==='error'?'2px solid #ef4444':'2px dashed #a3a3a3'; n.setAttribute('data-hal-relay', st); if(tt) n.title=tt; };
  const hash=async(s)=>{const e=new TextEncoder(); const b=await crypto.subtle.digest('SHA-256',e.encode(s)); return Array.from(new Uint8Array(b)).map(b=>b.toString(16).padStart(2,'0')).join(''); };
  const process=async(n,raw)=>{ try{ const parsed=JSON.parse(raw); const id= parsed?.id? String(parsed.id): await hash(raw); const payload={id,raw,parsed,source:'chatgpt-web',ts:Date.now()}; chrome.runtime.sendMessage({type:'HAL_CMD',payload},(r)=>{ if(chrome.runtime.lastError){tag(n,'error',chrome.runtime.lastError.message);return;} tag(n, r?.ok?'sent':'error', r?.message||'');}); }catch{ tag(n,'error','JSON parse failed'); } };
  const scan=(root=document)=>{ findBlocks(root).forEach(({node,raw})=>{ if(node.getAttribute('data-hal-relay')) return; tag(node,'queued','HAL Relay: queued'); process(node,raw); }); };
  new MutationObserver(m=>{ for(const x of m){ x.addedNodes?.forEach(n=>{ if(n instanceof HTMLElement) scan(n); }); } }).observe(document.body,{childList:true,subtree:true});
  window.addEventListener('load', scan);
})();
'@;
  'extension/service_worker.js' = @'
const DEFAULTS={renderEndpoint:'https://hal-ku4c.onrender.com/kev_ai/listener',localEndpoint:'http://127.0.0.1:8765/kev_ai/listener',sharedSecret:'',routeStrategy:'auto'}; let cache=new Set();
chrome.runtime.onMessage.addListener((m,s,r)=>{ if(m?.type!=='HAL_CMD') return; handle(m.payload).then(x=>r(x)); return true;});
async function cfg(){return await new Promise(res=>chrome.storage.sync.get(DEFAULTS,c=>res({...DEFAULTS,...c})));}
async function hmac(k,m){ if(!k) return; const e=new TextEncoder(); const K=await crypto.subtle.importKey('raw',e.encode(k),{name:'HMAC',hash:'SHA-256'},false,['sign']); const s=await crypto.subtle.sign('HMAC',K,e.encode(m)); return Array.from(new Uint8Array(s)).map(b=>b.toString(16).padStart(2,'0')).join(''); }
async function post(url,secret,body){ const sig=await hmac(secret,body.raw); const res=await fetch(url,{method:'POST',headers:{'Content-Type':'application/json',...(sig?{'X-KEV-Signature':sig}:{})},body:JSON.stringify(body)}); const json=await res.json().catch(()=>({})); return {ok:res.ok,status:res.status,json}; }
async function handle(p){ try{ const c=await cfg(); if(cache.has(p.id)) return {ok:true,message:'duplicate ignored'}; const t=(p?.parsed?.target||'').toLowerCase(); const s=c.routeStrategy; const wl= s==='local'||s==='both'||(s==='auto'&&(t==='local'||t==='both')); const wr= s==='render'||s==='both'||(s==='auto'&&(t==='render'||t==='both'||!t)); const posts=[]; if(wl) posts.push(post(c.localEndpoint,c.sharedSecret,p)); if(wr) posts.push(post(c.renderEndpoint,c.sharedSecret,p)); const rs=await Promise.allSettled(posts); cache.add(p.id); const ok=rs.some(x=>x.status==='fulfilled'&&x.value.ok); const msg=rs.map(x=>x.status==='fulfilled'?String(x.value.status):'ERR').join(' | '); return {ok,message:msg}; }catch(e){ return {ok:false,message:e?.message||'error'}; } }
'@;
  'extension/options.html' = @'
<!doctype html><html><head><meta charset="utf-8"/><title>HAL Relay Options</title><style>body{font-family:ui-sans-serif,system-ui;margin:24px}label{display:block;margin-top:12px}input,select{width:100%;padding:8px}.row{display:flex;gap:12px}.row>div{flex:1}.muted{color:#6b7280;font-size:12px}button{margin-top:18px;padding:10px 14px}</style></head><body><h1>HAL Relay</h1><label>Render Listener URL<input id="renderEndpoint" placeholder="https://.../kev_ai/listener"/></label><label>Local Listener URL<input id="localEndpoint" placeholder="http://127.0.0.1:8765/kev_ai/listener"/></label><div class="row"><div><label>Route Strategy<select id="routeStrategy"><option value="auto">auto</option><option value="render">render</option><option value="local">local</option><option value="both">both</option></select></label></div><div><label>Shared Secret<input id="sharedSecret" placeholder="optional but recommended"/></label></div></div><button id="save">Save</button><p class="muted">Use <code>target</code> in the command to steer routing when strategy=auto.</p><script src="options.js"></script></body></html>
'@;
  'extension/options.js' = @'
const DEFAULTS={renderEndpoint:'; $null }  # placeholder to avoid quoting hell
