<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>HAL Web Relay (SSD + Optional GitHub, with persistence)</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:0;background:#f8fafc;color:#0f172a}
    .wrap{max-width:980px;margin:24px auto;padding:0 16px}
    .card{background:#fff;border-radius:16px;box-shadow:0 6px 18px rgba(0,0,0,.06);padding:16px}
    h1{margin:0 0 8px;font-size:22px}
    label{display:block;margin:8px 0 4px;font-size:12px;color:#475569}
    input,textarea,select,button{font:inherit}
    input,textarea,select{width:100%;box-sizing:border-box;border:1px solid #e5e7eb;border-radius:10px;padding:10px 12px;background:#fff}
    textarea{min-height:160px;resize:vertical}
    .row{display:flex;gap:12px;align-items:flex-end}
    .row>.col{flex:1}
    .btn{padding:10px 14px;border:none;border-radius:12px;background:#111827;color:#fff;cursor:pointer}
    .btn.alt{background:#334155}
    .btn.ok{background:#16a34a}
    .btn.warn{background:#d97706}
    .log{font-family:ui-monospace,Consolas,Menlo,monospace;background:#0b1020;color:#e5e7eb;border-radius:12px;padding:12px;height:300px;overflow:auto;white-space:pre-wrap}
    .muted{color:#64748b;font-size:12px}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    .kbd{font-family:ui-monospace,Consolas,Menlo;background:#e5e7eb;border-radius:6px;padding:2px 6px}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>HAL Web Relay</h1>
      <p class="muted">
        Pick <b>GENESIS</b> once; this page can remember it. Paste a command, or use clipboard/Bookmarklet.
        With <b>Bypass Render</b>, we call GitHub directly (token can be remembered).
      </p>

      <div class="grid">
        <div class="card" style="padding:12px">
          <h3 style="margin:0 0 8px">Local SSD</h3>
          <div class="row">
            <div class="col">
              <label>SSD root</label>
              <input id="ssdLabel" placeholder="Not selected" disabled />
            </div>
            <div>
              <button class="btn" id="pickBtn">Choose Folder</button>
            </div>
            <div>
              <button class="btn alt" id="reconnectBtn" title="Try previously saved handle">Reconnect</button>
            </div>
          </div>
          <label><input type="checkbox" id="rememberSsd"> Remember SSD selection (uses IndexedDB)</label>
          <p class="muted">Drive letters don't matter—select the top folder (e.g. <b>GENESIS</b>).</p>
        </div>

        <div class="card" style="padding:12px">
          <h3 style="margin:0 0 8px">Remote (optional)</h3>
          <label><input type="checkbox" id="bypassRender"> Bypass Render (use GitHub API directly)</label>
          <div class="row">
            <div class="col">
              <label>GitHub Token (repo read/write)</label>
              <input id="ghToken" type="password" placeholder="fine-grained token"/>
            </div>
            <div class="col">
              <label>Repo</label>
              <input id="ghRepo" value="Demigodofa/hal" />
            </div>
          </div>
          <div class="row">
            <div class="col">
              <label>Branch</label>
              <input id="ghBranch" value="main" />
            </div>
            <div class="col">
              <label>Render Listener URL</label>
              <input id="renderUrl" value="https://hal-ku4c.onrender.com/kev_ai/listener"/>
            </div>
          </div>
          <div class="row">
            <div class="col">
              <label>Shared Secret (Render HMAC, optional)</label>
              <input id="sharedSecret" type="password" placeholder="match Render secret if set"/>
            </div>
            <div>
              <label>Mode</label>
              <select id="routeMode">
                <option value="auto" selected>auto</option>
                <option value="local">local</option>
                <option value="render">render</option>
                <option value="both">both</option>
              </select>
            </div>
          </div>
          <label><input type="checkbox" id="rememberSettings" checked> Remember settings (localStorage)</label>
        </div>
      </div>

      <label style="margin-top:10px">Command block or JSON</label>
      <textarea id="cmdInput" spellcheck="false" placeholder="Paste [KEV_AI::command]... or raw JSON here"></textarea>
      <div class="row" style="margin-top:8px">
        <div class="col">
          <button class="btn ok" id="runOnce">Process Once</button>
          <button class="btn alt" id="clearLog">Clear Log</button>
          <button class="btn" id="watchClipboard">Watch Clipboard</button>
        </div>
      </div>

      <h3 style="margin-top:14px">Bookmarklet</h3>
      <p class="muted">
        Drag this to your bookmarks bar. On a ChatGPT page containing a <span class="kbd">[KEV_AI::command]</span> block, click it to send the block here:
      </p>
      <textarea id="bookmarklet" readonly></textarea>

      <label style="margin-top:12px">Log</label>
      <div class="log" id="log"></div>
      <p class="muted">Browsers cannot run local shell; use Render for system commands if needed. Chromium browsers recommended.</p>
    </div>
  </div>

  <script>
    const $ = (s)=>document.querySelector(s);
    const log = (...a)=>{ const t=a.map(x=>typeof x==='string'?x:JSON.stringify(x,null,2)).join(' '); const el=$('#log'); el.textContent += (el.textContent? '\\n':'') + t; el.scrollTop=el.scrollHeight; };

    // ----- Settings persistence -----
    const LS_KEY = 'hal-web-relay-settings';
    const load = () => { try { return JSON.parse(localStorage.getItem(LS_KEY) || '{}'); } catch { return {}; } };
    const save = (o) => localStorage.setItem(LS_KEY, JSON.stringify(o));
    const S = Object.assign({
      renderUrl:'https://hal-ku4c.onrender.com/kev_ai/listener',
      sharedSecret:'',
      routeMode:'auto',
      bypassRender:false,
      ghToken:'',
      ghRepo:'Demigodofa/hal',
      ghBranch:'main',
      rememberSettings:true,
      rememberSsd:false
    }, load());

    // apply
    $('#renderUrl').value = S.renderUrl;
    $('#sharedSecret').value = S.sharedSecret;
    $('#routeMode').value = S.routeMode;
    $('#bypassRender').checked = !!S.bypassRender;
    $('#ghToken').value = S.ghToken || '';
    $('#ghRepo').value = S.ghRepo;
    $('#ghBranch').value = S.ghBranch;
    $('#rememberSettings').checked = !!S.rememberSettings;
    $('#rememberSsd').checked = !!S.rememberSsd;

    function maybeSave() {
      if (!$('#rememberSettings').checked) return;
      S.renderUrl = $('#renderUrl').value.trim();
      S.sharedSecret = $('#sharedSecret').value.trim();
      S.routeMode = $('#routeMode').value;
      S.bypassRender = $('#bypassRender').checked;
      S.ghToken = $('#ghToken').value;
      S.ghRepo = $('#ghRepo').value.trim();
      S.ghBranch = $('#ghBranch').value.trim();
      S.rememberSettings = $('#rememberSettings').checked;
      S.rememberSsd = $('#rememberSsd').checked;
      save(S);
    }
    ['input','change'].forEach(ev => {
      document.body.addEventListener(ev, (e) => {
        if (['INPUT','SELECT'].includes(e.target.tagName)) maybeSave();
      });
    });

    // ----- SSD persistence via IndexedDB (stores FileSystemDirectoryHandle) -----
    let ssdRoot = null; // FileSystemDirectoryHandle
    const DB_NAME = 'hal-relay';
    const DB_STORE = 'handles';
    function idb() { return new Promise((res,rej)=>{ const r=indexedDB.open(DB_NAME,1); r.onupgradeneeded=()=>{ r.result.createObjectStore(DB_STORE); }; r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error); }); }
    async function putHandle(key, handle) { const db = await idb(); return new Promise((res,rej)=>{ const tx=db.transaction(DB_STORE,'readwrite'); tx.objectStore(DB_STORE).put(handle,key); tx.oncomplete=()=>res(); tx.onerror=()=>rej(tx.error); }); }
    async function getHandle(key) { const db = await idb(); return new Promise((res,rej)=>{ const tx=db.transaction(DB_STORE,'readonly'); const req=tx.objectStore(DB_STORE).get(key); req.onsuccess=()=>res(req.result); req.onerror=()=>rej(req.error); }); }

    async function setSsd(handle) {
      ssdRoot = handle || null;
      $('#ssdLabel').value = ssdRoot ? (ssdRoot.name || '(selected)') : '';
      if (ssdRoot && $('#rememberSsd').checked) { try { await putHandle('ssdRoot', ssdRoot); } catch {} }
    }

    async function reconnectSsd() {
      try {
        const h = await getHandle('ssdRoot');
        if (!h) { log('no saved SSD handle'); return; }
        // request permission if needed
        let perm = await h.queryPermission({ mode:'readwrite' });
        if (perm !== 'granted') { perm = await h.requestPermission({ mode:'readwrite' }); }
        if (perm === 'granted') { await setSsd(h); log('SSD reconnected:', h.name); }
        else { log('SSD permission denied'); }
      } catch (e) { log('reconnect error:', e.message || e); }
    }

    $('#pickBtn').addEventListener('click', async () => {
      try {
        const h = await window.showDirectoryPicker();
        await setSsd(h);
        log('selected root:', h.name);
      } catch(e){ log('picker canceled'); }
    });
    $('#reconnectBtn').addEventListener('click', reconnectSsd);

    // auto-try reconnect on load if opted in
    window.addEventListener('DOMContentLoaded', () => { if ($('#rememberSsd').checked) reconnectSsd(); });

    // ----- Local FS helpers -----
    const splitPath = (p)=> String(p).split('/').filter(Boolean).filter(s=>s!=='.'&&s!=='..');
    async function ensureDir(root, rel){ let d=root; for(const part of splitPath(rel)){ d = await d.getDirectoryHandle(part,{create:true}); } return d; }
    async function getParent(root, rel, create){ const parts=splitPath(rel); if(!parts.length) throw new Error('empty path'); let d=root; for(let i=0;i<parts.length-1;i++){ d = await d.getDirectoryHandle(parts[i],{create}); } return {dir:d,name:parts[parts.length-1]}; }
    async function writeFile(root, rel, content){ const {dir,name}=await getParent(root,rel,true); const fh=await dir.getFileHandle(name,{create:true}); const w=await fh.createWritable(); await w.write(content||''); await w.close(); return {path:rel,bytes:(content||'').length}; }
    async function readFile(root, rel){ const {dir,name}=await getParent(root,rel,false); const fh=await dir.getFileHandle(name,{create:false}); const file=await fh.getFile(); return {path:rel, content: await file.text()}; }
    async function listDir(root, rel='.') { const dir = rel==='.'? root : await ensureDir(root, rel); const items=[]; for await (const [name,handle] of dir.entries()){ const item={name,is_dir:handle.kind==='directory'}; if(handle.kind==='file'){ const f=await handle.getFile(); item.size=f.size; } items.push(item);} return {path:rel, items}; }
    async function deleteFile(root, rel){ const {dir,name}=await getParent(root,rel,false); await dir.removeEntry(name,{recursive:false}); return {path:rel,deleted:true}; }

    // ----- Bookmarklet + postMessage -----
    function makeBookmarklet() {
      const url = location.origin + location.pathname;
      const js = `
javascript:(function(){
  try{
    var S='[KEV_AI::command]',E='[/KEV_AI::command]',raw=null;
    var blocks=document.querySelectorAll('pre,code,.markdown');
    for(var i=0;i<blocks.length;i++){var t=blocks[i].innerText||'';var s=t.indexOf(S),e=t.indexOf(E);if(s!=-1&&e!=-1&&e>s){raw=t.slice(s+S.length,e).trim();break;}}
    if(!raw){alert('No [KEV_AI::command] block found.');return;}
    var w=open('${url}','_blank'); setTimeout(function(){ w && w.postMessage({type:'HAL_PAYLOAD',raw:raw}, '*'); }, 500);
  }catch(e){alert('bookmarklet error: '+(e&&e.message||e));}
})();`.trim();
      $('#bookmarklet').value = js;
    }
    makeBookmarklet();

    window.addEventListener('message', (ev) => {
      if (ev.data && ev.data.type === 'HAL_PAYLOAD' && typeof ev.data.raw === 'string') {
        $('#cmdInput').value = `[KEV_AI::command]\n${ev.data.raw}\n[/KEV_AI::command]`;
        log('received payload from bookmarklet');
      }
    });

    // ----- Clipboard watch -----
    let watchTimer = null;
    $('#watchClipboard').addEventListener('click', async (btn) => {
      if (watchTimer) { clearInterval(watchTimer); watchTimer=null; btn.target.textContent='Watch Clipboard'; return; }
      try { await navigator.permissions.query({ name:'clipboard-read' }); } catch {}
      btn.target.textContent='Watching…';
      let last='';
      watchTimer = setInterval(async () => {
        try {
          const t = await navigator.clipboard.readText();
          if (t && t !== last && t.includes('[KEV_AI::command]')) {
            last = t;
            $('#cmdInput').value = t;
            log('clipboard captured block');
            processOnce();
          }
        } catch {}
      }, 1500);
    });

    // ----- HMAC / Render path -----
    async function hmacSHA256(key, message){ if(!key) return; const enc=new TextEncoder(); const k=await crypto.subtle.importKey('raw', enc.encode(key), {name:'HMAC',hash:'SHA-256'}, false, ['sign']); const sig=await crypto.subtle.sign('HMAC', k, enc.encode(message)); return Array.from(new Uint8Array(sig)).map(b=>b.toString(16).padStart(2,'0')).join(''); }
    async function postRender(url, secret, body){ const sig = secret ? await hmacSHA256(secret, body.raw) : undefined; const res = await fetch(url,{ method:'POST', headers:{ 'Content-Type':'application/json', ...(sig?{'X-KEV-Signature':sig}:{}) }, body: JSON.stringify(body)}); const json = await res.json().catch(()=>({})); return { ok: res.ok, status: res.status, json }; }

    // ----- GitHub (bypass) helpers -----
    const ghBase = 'https://api.github.com';
    const ghHdrs = (token)=> ({ 'Accept':'application/vnd.github+json', ...(token?{'Authorization':`Bearer ${token}`}:{}) });
    const b64e = (txt)=> btoa(unescape(encodeURIComponent(txt)));
    const b64d = (b64)=> decodeURIComponent(escape(atob(b64)));
    const encSeg = (p)=> String(p).split('/').map(encodeURIComponent).join('/');

    async function ghGetFile({repo, path, ref}){
      const token = $('#bypassRender').checked ? $('#ghToken').value.trim() : '';
      const url = `${ghBase}/repos/${repo}/contents/${encSeg(path)}${ref?`?ref=${encodeURIComponent(ref)}`:''}`;
      const res = await fetch(url, { headers: ghHdrs(token) });
      if (!res.ok) throw new Error(`github GET ${res.status}`);
      const json = await res.json();
      if (json && json.content && json.encoding === 'base64') { json.text = b64d(json.content.replace(/\n/g,'')); }
      return json;
    }

    async function ghPutFile({repo, path, content, message, branch}){
      const token = $('#bypassRender').checked ? $('#ghToken').value.trim() : '';
      const url = `${ghBase}/repos/${repo}/contents/${encSeg(path)}`;
      // detect existing to include sha
      let sha = undefined;
      try {
        const refQ = branch ? `?ref=${encodeURIComponent(branch)}` : '';
        const cur = await fetch(url + refQ, { headers: ghHdrs(token) });
        if (cur.ok) { const j = await cur.json(); sha = j.sha; }
      } catch {}
      const body = { message: message || `update ${path}`, content: b64e(content || ''), branch: branch || $('#ghBranch').value.trim() || 'main', sha };
      const res = await fetch(url, { method:'PUT', headers: { ...ghHdrs(token), 'Content-Type':'application/json' }, body: JSON.stringify(body) });
      if (!res.ok) throw new Error(`github PUT ${res.status}`);
      return await res.json();
    }

    // ----- Command processing -----
    const extractBlock=(text)=>{ const s=text.indexOf('[KEV_AI::command]'); const e=text.indexOf('[/KEV_AI::command]'); return (s!==-1&&e!==-1&&e>s)? text.slice(s+'[KEV_AI::command]'.length,e).trim() : text.trim(); };

    async function processOnce() {
      try{
        const rawAll = $('#cmdInput').value;
        const raw = extractBlock(rawAll);
        const parsed = JSON.parse(raw);
        const id = parsed.id || Math.random().toString(36).slice(2);
        const target = (parsed.target||'local').toLowerCase();
        const mode = $('#routeMode').value; // auto|local|render|both
        const effective = mode==='auto'? target : mode;
        const body = { id, raw, parsed, source:'web-relay', ts: Date.now() };

        // Local ops
        if ((effective==='local'||effective==='both')){
          if(!ssdRoot){ log('local: no SSD selected'); }
          else {
            const op=(parsed.op||'').toLowerCase(); const a=parsed.args||{};
            if(op==='file_ops.read_file'||op==='read_file'){ log('local read:', await readFile(ssdRoot, a.path)); }
            else if(op==='file_ops.write_file'||op==='write_file'){ log('local write:', await writeFile(ssdRoot, a.path, a.content||'')); }
            else if(op==='file_ops.list_dir'||op==='list_dir'){ log('local list:', await listDir(ssdRoot, a.path||'.')); }
            else if(op==='file_ops.mkdirs'||op==='mkdirs'){ await ensureDir(ssdRoot, a.path); log('local mkdirs ok:', a.path); }
            else if(op==='file_ops.delete_file'||op==='delete_file'){ log('local delete:', await deleteFile(ssdRoot, a.path)); }
            else if(op==='system_control.run'||op==='run_cmd'){ log('local run_cmd ignored in browser'); }
            else { log('local unknown op:', op); }
          }
        }

        // Remote: direct GitHub when bypass checked, else Render
        const bypass = $('#bypassRender').checked;
        if ((effective==='render'||effective==='both') || (effective==='local'&&target==='render')){
          const op=(parsed.op||'').toLowerCase();
          if (bypass && op.startsWith('github.')) {
            const repo = (parsed.args && parsed.args.repo) || $('#ghRepo').value.trim();
            if (op==='github.get_file') {
              const out = await ghGetFile({repo, path: parsed.args.path, ref: parsed.args.ref || $('#ghBranch').value.trim()});
              log('github get_file:', { path: parsed.args.path, size: out.size, sha: out.sha });
            } else if (op==='github.put_file') {
              const out = await ghPutFile({repo, path: parsed.args.path, content: parsed.args.content || '', message: parsed.args.message || '', branch: parsed.args.branch || $('#ghBranch').value.trim()});
              log('github put_file:', { path: parsed.args.path, commit: out?.commit?.sha?.slice(0,7) });
            } else {
              log('github op not supported in bypass mode:', op);
            }
          } else {
            const rurl = $('#renderUrl').value.trim();
            const secret = $('#sharedSecret').value.trim();
            const res = await postRender(rurl, secret, body); log('render response:', res.status, res.json);
          }
        }
      }catch(e){ log('error:', e?.message||e); }
    }

    $('#runOnce').addEventListener('click', processOnce);
    $('#clearLog').addEventListener('click', ()=>{ $('#log').textContent=''; });

  </script>
</body>
</html>
